<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"xbest.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"right",display:"hide",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="本文主要从ThreadLocal的源代码出发，分析了以下几个问题：  ThreadLocal的定义、原理及实现 ThreadLocal到底存不存在内存泄漏 ThreadLocal在开源代码中的应用示例 ThreadLocal的适用场景"><meta property="og:type" content="article"><meta property="og:title" content="浅析ThreadLocal原理、实现及适用场景"><meta property="og:url" content="http://xbest.github.io/ThreadLocal/index.html"><meta property="og:site_name" content="半亩方塘一鉴开"><meta property="og:description" content="本文主要从ThreadLocal的源代码出发，分析了以下几个问题：  ThreadLocal的定义、原理及实现 ThreadLocal到底存不存在内存泄漏 ThreadLocal在开源代码中的应用示例 ThreadLocal的适用场景"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/xbest/image-hosting/main/img/20210711155545.jpg"><meta property="og:image" content="https://raw.githubusercontent.com/xbest/image-hosting/main/img/20210711142456.png"><meta property="og:image" content="https://raw.githubusercontent.com/xbest/image-hosting/main/img/20210711161412.webp"><meta property="article:published_time" content="2021-07-10T16:00:00.000Z"><meta property="article:modified_time" content="2021-07-11T16:26:04.001Z"><meta property="article:author" content="长安大诗人"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://raw.githubusercontent.com/xbest/image-hosting/main/img/20210711155545.jpg"><link rel="canonical" href="http://xbest.github.io/ThreadLocal/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>浅析ThreadLocal原理、实现及适用场景 | 半亩方塘一鉴开</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">半亩方塘一鉴开</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">天光云影共徘徊</p></div><div class="site-nav-right"><div class="toggle popup-trigger"></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://xbest.github.io/ThreadLocal/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="长安大诗人"><meta itemprop="description" content="一亩三分地"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="半亩方塘一鉴开"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">浅析ThreadLocal原理、实现及适用场景</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-07-11 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-11T00:00:00+08:00">2021-07-11</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-07-12 00:26:04" itemprop="dateModified" datetime="2021-07-12T00:26:04+08:00">2021-07-12</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">源码浅析</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>6 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>本文主要从<code>ThreadLocal</code>的源代码出发，分析了以下几个问题：</p><ul><li><code>ThreadLocal</code>的定义、原理及实现</li><li><code>ThreadLocal</code>到底存不存在内存泄漏</li><li><code>ThreadLocal</code>在开源代码中的应用示例</li><li><code>ThreadLocal</code>的适用场景</li></ul><span id="more"></span><h2 id="ThreadLocal定义、原理及实现"><a href="#ThreadLocal定义、原理及实现" class="headerlink" title="ThreadLocal定义、原理及实现"></a>ThreadLocal定义、原理及实现</h2><h3 id="ThreadLocal定义"><a href="#ThreadLocal定义" class="headerlink" title="ThreadLocal定义"></a>ThreadLocal定义</h3><p>要研究<code>ThreadLocal</code>，我们先要弄明白<code>ThreadLocal</code>是什么？先来看一下源代码中官方给出的描述：</p><blockquote><p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable.<br>ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID). Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</p></blockquote><p>官方给出的定义是ThreadLocal提供了<strong>线程本地的变量</strong>。它与普通的变量的区别在于，每个使用该变量的线程都会初始化一份<strong>完全独立的实例副本</strong>。 建议<code>ThreadLocal</code>定义为<code>private static field</code>。<br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html">Java中总共定义了以下四种变量</a>：</p><ul><li>Instance Variables(Non-Static Fields)</li><li>Class Variables(Static Fields)</li><li>Local Variables</li><li>Parameters</li></ul><p>那么什么是<code>thread-local variables</code>呢？从字面意思来看就是<code>Local Variables</code>，就是本地变量或者局部变量，但是本地变量的作用域是方法内部， 也就是<code>method-local variables</code>，所以从这个角度来分析就是作用域不同，<code>thread-local variables</code>的作用域就是thread内部， 也就是不局限于方法内部，所以<code>ThreadLocal</code>的作用域就是整个thread内。</p><h3 id="ThreadLocal设计"><a href="#ThreadLocal设计" class="headerlink" title="ThreadLocal设计"></a>ThreadLocal设计</h3><p><img src="https://raw.githubusercontent.com/xbest/image-hosting/main/img/20210711155545.jpg" alt="ThreadLocal原理图"> 如上图所示，<code>ThreadLocal</code>变量其实仅仅是作为<code>ThreadLocalMap</code>中的key来存储数据的，即<code>Thread</code>中的<code>ThreadLocalMap</code>类型的<code>threadLocals</code>字段才是真正存储数据的地方。<br><em><strong>为什么不设计成<code>ThreadLocal</code>类中有个<code>Map</code>，将线程Id作为key，<code>ThreadLocalMap</code>实例作为value呢？</strong></em><br>现在的设计思路大概有以下几个好处：</p><ul><li><code>Map</code>中<code>Entry</code>的数量减少了，疑问中的设计<code>Entry</code>中的数量是线程的数量，而JDK中的设计<code>Entry</code>的数量是<code>ThreadLocal</code>实例的数量</li><li>将<code>ThreadLocalMap</code>放到线程中，可以随着线程的销毁而销毁，减少内存使用量</li><li>每个线程在访问变量时，都是访问的本地副本，相对于<code>ThreadLocal</code>类中的<code>Map</code>设计，性能有很大提高，需要考虑多线程并发的问题</li></ul><p><em><strong>为什么要用<code>ThreadLocalMap</code>来存储变量，<code>ThreadLocal.set()</code>方法也没有任何<code>key/value</code>参数？</strong></em><br>这是我一开始阅读源代码时的一个疑问，后来发现<code>ThreadLocal.set()</code>是没有任何参数，但是一个线程可能存储多个<code>ThreadLocal</code>实例对象关联的值。</p><h3 id="ThreadLocal实现"><a href="#ThreadLocal实现" class="headerlink" title="ThreadLocal实现"></a>ThreadLocal实现</h3><p>首先看一下<code>ThreadLocal</code>的源代码，主要方法为<code>set</code>及<code>get</code>方法。 <img src="https://raw.githubusercontent.com/xbest/image-hosting/main/img/20210711142456.png" alt="ThreadLocal源码图"> 如上图所示，<code>ThreadLocal</code>中并没有存储变量的字段，那么调用<code>ThreadLocal.set</code>方法，将变量存储到哪里了呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>set</code>方法源代码可以看到，真正存储变量数据信息的<code>ThreadLocalMap</code>不在<code>ThreadLocal</code>中，而是根据<code>Thread.currentThread()</code>查询或者创建的。 那么<code>getMap</code>和<code>createMap</code>是怎么实现的呢？我们继续跟踪查看这两方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getMap</code>的方法简单到不能再简单了，就是直接返回了<code>Thread.currentThread().threadLocals</code>，非常清晰地能够看出真正存储变量数据的地方是当前线程的字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createMap</code>的方法也是简单到了极致，直接就是给当前线程的<code>threadLocals</code>字段赋值一个新创建的<code>ThreadLocalMap</code>对象的实例。 通过<code>set</code>和<code>get</code>两个关键方法的源代码可以基本上看出<code>ThreadLocal</code>的实现了，也真正明白了的意思了。</p><blockquote><p>每个使用<code>ThreadLocal</code>的线程都独立初始化了一份实例的副本</p></blockquote><h3 id="ThreadLocalMap源码"><a href="#ThreadLocalMap源码" class="headerlink" title="ThreadLocalMap源码"></a>ThreadLocalMap源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>中只采用了数组来存储对象，<code>ThreadLocal.ThreadLocalMap.Entry</code>继承了<code>WeakReference</code>，只有一个类型为<code>Object</code>的<code>value</code>字段， 没有<code>next</code>指针，所以没有采用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining">链地址法</a>去解决 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hash_table#Collision_resolution">哈希冲突</a>， 而是采用了<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hash_table#Open_addressing">开放地址法</a>（线性探测法、二次探测法、伪随机探测法）来解决哈希冲突， <code>ThreadLocal</code>采用的是线性探测再散列，除此之外还有<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hash_table#2-choice_hashing">再哈希法</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">        <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">        <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">        <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line">        <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                replaceStaleEntry(key, value, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">        <span class="keyword">int</span> sz = ++size;</span><br><span class="line">        <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">            rehash();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>存储元素的过程如下：</p><ol><li>斐波那契散列计算数组下标</li><li><code>for</code>循环判断元素是否存在，当前下标不存在元素时，直接设置数组<code>tab[i] = new Entry(key, value)</code></li><li>当前下标存在元素时，判断key值是否相等，如果相等，那么直接更新当前元素</li><li>当前下标存在元素，且key值不相等，那么探测式清理元素<code>replaceStaleEntry</code></li></ol><h3 id="ThreadLocal的清除算法"><a href="#ThreadLocal的清除算法" class="headerlink" title="ThreadLocal的清除算法"></a>ThreadLocal的清除算法</h3><p><strong>探测式清理<code>replaceStaleEntry</code>：</strong><br>从当前<code>key</code>为<code>null</code>的元素开始，向后不断清理，直到再次遇到<code>key</code>为<code>null</code>的元素为止<br><strong>启发式清理<code>cleanSomeSlots</code>：</strong><br>试探性的扫描数组，寻找过期元素，执行对数扫描次数，但是会导致插入操作花费O(n)时间</p><blockquote><p>Heuristically scan some cells looking for stale entries. This is invoked when either a new element is added, or another stale one has been expunged. It performs a logarithmic number of scans, as a balance between no scanning (fast but retains garbage) and a number of scans proportional to number of elements, that would find all garbage but would cause some insertions to take O(n) time.</p></blockquote><h2 id="ThreadLocal到底存不存在内存泄漏"><a href="#ThreadLocal到底存不存在内存泄漏" class="headerlink" title="ThreadLocal到底存不存在内存泄漏"></a>ThreadLocal到底存不存在内存泄漏</h2><h3 id="什么是内存泄漏（memory-leak）"><a href="#什么是内存泄漏（memory-leak）" class="headerlink" title="什么是内存泄漏（memory leak）"></a>什么是内存泄漏（memory leak）</h3><blockquote><p>A Memory Leak is a situation when there are objects present in the heap that are no longer used, but the garbage collector is unable to remove them from memory and, thus they are unnecessarily maintained.</p></blockquote><p><img src="https://raw.githubusercontent.com/xbest/image-hosting/main/img/20210711161412.webp" alt="memory leak"> 内存泄漏就是heap中的对象已经没有其它地方在使用了，但是GC却不能回收这块内存，总结就是以下两点：</p><ul><li>线程或者进程中没有地方<strong>真正</strong>在使用该对象</li><li>GC不能回收该对象</li></ul><h3 id="ThreadLocal内存泄漏分析"><a href="#ThreadLocal内存泄漏分析" class="headerlink" title="ThreadLocal内存泄漏分析"></a>ThreadLocal内存泄漏分析</h3><p>结合内存泄漏的两个特征，我们针对<code>ThreadLocal</code>进行分析以下是否存在内存泄漏。我们先看一下<code>ThreadLocal</code>的典型应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Thread local variable containing user</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; userThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;User&gt;();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Returns the current user</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userThreadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userThreadLocal.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们有一个线程池，线程池里的线程每次都会处理<code>User</code>相关数据，假设我们从线程池中取出线程A，在线程A的第一个方法入口时调用<code>UserContext.set</code>方法，保存<code>User</code>信息， 然后在线程A中调用<code>UserContext.get</code>方法去获取<code>User</code>信息，在线程A退出时，即不需要当前<code>User</code>信息了，此时满足了内存泄漏的第一个条件即这个<code>User</code>不再被使用。 但是从<code>userThreadLocal</code>的角度来看，其实下次还是会被别的线程（例如线程B）使用的，即使来的新请求又被线程A所处理，那么这次线程A存储的<code>User</code>也不是上次的<code>User</code>了。<br>在代码中可以看到<code>ThreadLocal</code>是<code>private static</code>的，也就是<code>Class Variables</code>，只有当类卸载的时候才会被回收，所以GC不会回收<code>userThreadLocal</code>， 同时由于线程A在线程池中所以线程A也不会被释放，那么线程A所持有的<code>threadLocals</code>也不会被回收，那么<code>threadLocals</code>中所存储的<code>User</code>对象当然也就不会被GC回收， 满足了内存泄漏的第二个条件，从这个角度来看的话，确实存在内存泄漏。<br>但是内存泄漏的第一个条件改为<strong>线程或者内存中不能通过引用访问到该对象</strong>，那么此时就不满足内存泄漏了， 因为即使线程A返回到线程池后，下次再进来的话还是能访问到该<code>User</code>对象的，如果该<code>User</code>对象没有被覆盖的话。</p><h2 id="ThreadLocal在开源代码中的应用示例"><a href="#ThreadLocal在开源代码中的应用示例" class="headerlink" title="ThreadLocal在开源代码中的应用示例"></a>ThreadLocal在开源代码中的应用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Transactional resources&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Transaction synchronizations&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Current transaction name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Current transaction read-only status&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Current transaction isolation level&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">            <span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">&quot;Actual transaction active&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Transaction应用代码示例</p><h2 id="ThreadLocal的适用场景"><a href="#ThreadLocal的适用场景" class="headerlink" title="ThreadLocal的适用场景"></a>ThreadLocal的适用场景</h2><ul><li>用户全局Token/Session</li><li><code>SimpleDateFormat</code>线程安全问题</li><li>MDC、TraceId</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>ThreadLocal</code>不能解决多线程共享变量的问题，也不能当作锁来使用，但是可以通过隔离来解决线程安全的问题</li><li><code>ThreadLocal</code>采用斐波那契散数列计算散列，黄金分割点2^32*0.6180339887计算得出<code>HASH_INCREMENT = 0x61c88647</code></li><li><code>ThreadLocal</code>采用探测式清理和启发式清理过期元素</li><li><code>ThreadLocal</code>中的<code>key</code>为弱引用，当key已经没有强引用时，可能会发生内存泄漏，要显示的调用<code>remove</code></li><li><code>ThreadLocal</code>采用开放地址法解决哈希冲突</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/AbstractQueuedSynchronizer/" rel="prev" title="AbstractQueuedSynchronizer源码浅析"><i class="fa fa-chevron-left"></i> AbstractQueuedSynchronizer源码浅析</a></div><div class="post-nav-item"><a href="/Git-Windows-ZH-CN-Messy-Code/" rel="next" title="Git Windows中文乱码">Git Windows中文乱码 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal%E5%AE%9A%E4%B9%89%E3%80%81%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">ThreadLocal定义、原理及实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">ThreadLocal定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.</span> <span class="nav-text">ThreadLocal设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.</span> <span class="nav-text">ThreadLocal实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap%E6%BA%90%E7%A0%81"><span class="nav-number">1.4.</span> <span class="nav-text">ThreadLocalMap源码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E7%9A%84%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">ThreadLocal的清除算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal%E5%88%B0%E5%BA%95%E5%AD%98%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">ThreadLocal到底存不存在内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88memory-leak%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">什么是内存泄漏（memory leak）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90"><span class="nav-number">2.2.</span> <span class="nav-text">ThreadLocal内存泄漏分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal%E5%9C%A8%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.</span> <span class="nav-text">ThreadLocal在开源代码中的应用示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.</span> <span class="nav-text">ThreadLocal的适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">长安大诗人</p><div class="site-description" itemprop="description">一亩三分地</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xbest" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xbest" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">长安大诗人</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">13k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">12 分钟</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script></body></html>